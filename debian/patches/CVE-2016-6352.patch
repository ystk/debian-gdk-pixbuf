Index: gdk-pixbuf-2.31.1/gdk-pixbuf/io-ico.c
===================================================================
--- gdk-pixbuf-2.31.1.orig/gdk-pixbuf/io-ico.c	2019-12-19 11:42:27.917616701 +0100
+++ gdk-pixbuf-2.31.1/gdk-pixbuf/io-ico.c	2019-12-19 11:54:38.414121674 +0100
@@ -23,7 +23,7 @@
  */
 
 #undef DUMPBIH
-
+#define DEBUG(s)
 #define INFOHEADER_SIZE 40
 
 /*
@@ -78,14 +78,14 @@
 };
 
 #ifdef DUMPBIH
-/* 
+/*
 
 DumpBIH printf's the values in a BitmapInfoHeader to the screen, for 
 debugging purposes.
 
 */
 static void DumpBIH(unsigned char *BIH)
-{				
+{
 	printf("biSize      = %i \n",
 	       (int)(BIH[3] << 24) + (BIH[2] << 16) + (BIH[1] << 8) + (BIH[0]));
 	printf("biWidth     = %i \n",
@@ -128,6 +128,8 @@
 /* Score the various parts of the icon */
 struct ico_direntry_data {
 	gint ImageScore;
+        gint width;
+        gint height;
 	gint DIBoffset;
 	gint x_hot;
 	gint y_hot;
@@ -223,10 +225,10 @@
 
 	/* First word should be 0 according to specs */
 	if (((Data[1] << 8) + Data[0]) != 0) {
-		g_set_error_literal (error,
-				     GDK_PIXBUF_ERROR,
-				     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
-				     _("Invalid header in icon"));
+		g_set_error (error,
+			     GDK_PIXBUF_ERROR,
+			     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+			     _("Invalid header in icon (%s)"), "first word");
 		return;
 
 	}
@@ -237,18 +239,19 @@
 
 	/* If it is not a cursor make sure it is actually an icon */
 	if (!State->cursor && imgtype != 1) {
-		g_set_error_literal (error,
-				     GDK_PIXBUF_ERROR,
-				     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
-				     _("Invalid header in icon"));
+		g_set_error (error,
+			     GDK_PIXBUF_ERROR,
+			     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+			     _("Invalid header in icon (%s)"), "image type");
 		return;
 	}
 
-
  	IconCount = (Data[5] << 8) + (Data[4]);
 	
  	State->HeaderSize = 6 + IconCount*16;
 
+        DEBUG(g_print ("Image type: %d (%s)\nImage count: %d\n", imgtype, imgtype == 2 ? "cursor" : "icon", IconCount));
+
  	if (State->HeaderSize>State->BytesInHeaderBuf) {
  		guchar *tmp=g_try_realloc(State->HeaderBuf,State->HeaderSize);
 		if (!tmp) {
@@ -270,15 +273,38 @@
 	State->entries = 0;
 	Ptr = Data + 6;
 	for (I=0;I<IconCount;I++) {
+                int width;
+                int height;
+                int x_hot;
+                int y_hot;
+                int data_size;
+                int data_offset;
+
+                width = Ptr[0];
+                height = Ptr[1];
+                x_hot = (Ptr[5] << 8) + Ptr[4];
+                y_hot = (Ptr[7] << 8) + Ptr[6];
+                data_size = (Ptr[11] << 24) + (Ptr[10] << 16) + (Ptr[9] << 8) + (Ptr[8]);
+                data_offset = (Ptr[15] << 24) + (Ptr[14] << 16) + (Ptr[13] << 8) + (Ptr[12]);
+                DEBUG(g_print ("Image %d: %d x %d\n\tPalette: %d\n", I, width, height, {tr[2]);
+                if (imgtype == 2)
+                  g_print ("\tHotspot: %d x %d\n", x_hot, y_hot);
+                else
+                  g_print ("\tColor planes: %d\n\tBits per pixel: %d\n", x_hot, y_hot);
+                g_print ("\tSize: %d\n\tOffset: %d\n", data_size, data_offset);)
+
 		entry = g_new0 (struct ico_direntry_data, 1);
-		entry->ImageScore = (Ptr[11] << 24) + (Ptr[10] << 16) + (Ptr[9] << 8) + (Ptr[8]);
-		entry->x_hot = (Ptr[5] << 8) + Ptr[4];
-		entry->y_hot = (Ptr[7] << 8) + Ptr[6];
-		entry->DIBoffset = (Ptr[15]<<24)+(Ptr[14]<<16)+
-		                   (Ptr[13]<<8) + (Ptr[12]);
+                entry->ImageScore = data_size;
+ 
+                entry->width = width ? width : 256;
+                entry->height = height ? height : 256;
+                entry->x_hot = x_hot;
+                entry->y_hot = y_hot;
+                entry->DIBoffset = data_offset;
+
 		State->entries = g_list_insert_sorted (State->entries, entry, compare_direntry_scores);
 		Ptr += 16;
-	} 
+	}
 
 	/* Now go through and find one we can parse */
 	entry = NULL;
@@ -286,19 +312,19 @@
 		entry = l->data;
 
 		if (entry->DIBoffset < 0) {
-			g_set_error_literal (error,
-			                     GDK_PIXBUF_ERROR,
-			                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
-			                     _("Invalid header in icon"));
+			g_set_error (error,
+			             GDK_PIXBUF_ERROR,
+			             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+			             _("Invalid header in icon (%s)"), "dib offset");
 			return;
 		}
 
                 /* Avoid invoking undefined behavior in the State->HeaderSize calculation below */
                 if (entry->DIBoffset > G_MAXINT - INFOHEADER_SIZE) {
-			g_set_error_literal (error,
-			                     GDK_PIXBUF_ERROR,
-			                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
-			                     _("Invalid header in icon"));
+			g_set_error (error,
+			             GDK_PIXBUF_ERROR,
+			             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+			             _("Invalid header in icon (%s)"), "header size");
 			return;
 		}
 
@@ -348,9 +374,9 @@
 
 #ifdef DUMPBIH
 	DumpBIH(BIH);
-#endif	
+#endif
 	/* Add the palette to the headersize */
-		
+
 	State->Header.width =
 	    (int)(BIH[7] << 24) + (BIH[6] << 16) + (BIH[5] << 8) + (BIH[4]);
 	if (State->Header.width == 0) {
@@ -370,11 +396,27 @@
                                      _("Icon has zero height"));
 		return;
 	}
-	State->Header.depth = (BIH[15] << 8) + (BIH[14]);
 
+        /* Negative heights mean top-down pixel-order */
+        if (State->Header.height < 0) {
+                State->Header.height = -State->Header.height;
+                State->Header.Negative = 1;
+        }
+        if (State->Header.width < 0) {
+                State->Header.width = -State->Header.width;
+        }
+ 
+        if (State->Header.width != entry->width ||
+            State->Header.height != entry->height) {
+               g_set_error (error,
+                             GDK_PIXBUF_ERROR,
+                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+                             _("Invalid header in icon (%s)"), "image size");
+               return;
+        }
+
+	State->Header.depth = (BIH[15] << 8) + (BIH[14]);
 	State->Type = State->Header.depth;	
-	if (State->Lines>=State->Header.height)
-		State->Type = 1; /* The transparency mask is 1 bpp */
 	
 	/* Determine the  palette size. If the header indicates 0, it
 	   is actually the maximum for the bpp. You have to love the
@@ -391,10 +433,10 @@
 	State->HeaderSize+=I;
 	
 	if (State->HeaderSize < 0) {
-		g_set_error_literal (error,
-                                     GDK_PIXBUF_ERROR,
-                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
-                                     _("Invalid header in icon"));
+		g_set_error (error,
+                             GDK_PIXBUF_ERROR,
+                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+                             _("Invalid header in icon (%s)"), "palette size");
 		return;
 	}
 
@@ -413,17 +455,6 @@
  	if (Bytes < State->HeaderSize)
  		return;
 
-	/* Negative heights mean top-down pixel-order */
-	if (State->Header.height < 0) {
-		State->Header.height = -State->Header.height;
-		State->Header.Negative = 1;
-	}
-	if (State->Header.width < 0) {
-		State->Header.width = -State->Header.width;
-	}
-	g_assert (State->Header.width > 0);
-	g_assert (State->Header.height > 0);
-
         if (State->Type == 32)
                 State->LineWidth = State->Header.width * 4;
         else if (State->Type == 24)
@@ -466,7 +497,6 @@
 
 
 	if (State->pixbuf == NULL) {
-#if 1
 		if (State->size_func) {
 			gint width = State->Header.width;
 			gint height = State->Header.height;
@@ -477,7 +507,6 @@
 				return;
 			}
 		}
-#endif
 
 		State->pixbuf =
 		    gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8,
